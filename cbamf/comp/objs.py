import numpy as np
from scipy.special import erf
from scipy.weave import inline

from cbamf.util import Tile, cdd, amin, amax

# maximum number of iterations to get an exact volume
MAX_VOLUME_ITERATIONS = 10

#=============================================================================
# Forms of the platonic sphere interpolation function
#=============================================================================
def norm(a):
    return np.sqrt((a**2).sum(axis=-1))

def inner(r, p, a, zscale=1.0):
    eps = np.array([1,1,1])*1e-8
    s = np.array([zscale, 1.0, 1.0])

    d = (r-p-eps)*s
    n = norm(d)
    dhat = d / n[...,None]

    o = norm((d - a*dhat)/s)
    return o * np.sign(n - a)

def sphere_lerp(dr, a, alpha):
    """ Linearly interpolate the pixels for the platonic object """
    return (1-np.clip((dr+alpha) / (2*alpha), 0, 1))

def sphere_logistic(dr, a, alpha):
    """ Classic logistic interpolation """
    return 1.0/(1.0 + np.exp(alpha*dr))

def sphere_triangle_cdf(dr, a, alpha):
    """ Cumulative distribution function for the traingle distribution """
    p0 = (dr+alpha)**2/(2*alpha**2)*(0 > dr)*(dr>-alpha)
    p1 = 1*(dr>0)-(alpha-dr)**2/(2*alpha**2)*(0<dr)*(dr<alpha)
    return (1-np.clip(p0+p1, 0, 1))


def sphere_analytical_gaussian(dr, a, alpha=0.2765):
    """
    Analytically calculate the sphere's functional form by convolving the
    Heavyside function with first order approximation to the sinc, a Gaussian.
    The alpha parameters controls the width of the approximation -- should be
    1, but is fit to be roughly 0.2765
    """
    term1 = 0.5*(erf((dr+2*a)/(alpha*np.sqrt(2))) + erf(-dr/(alpha*np.sqrt(2))))
    term2 = np.sqrt(0.5/np.pi)*(alpha/(dr+a+1e-10)) * (
                np.exp(-0.5*dr**2/alpha**2) - np.exp(-0.5*(dr+2*a)**2/alpha**2)
            )
    return term1 - term2

def sphere_analytical_gaussian_trim(dr, a, alpha=0.2765, cut=1.6):
    """
    See sphere_analytical_gaussian_exact.

    I trimmed to terms from the functional form that are essentially zero (1e-8)
    for r0 > cut (~1.5), a fine approximation for these platonic anyway.
    """
    m = np.abs(dr) <= cut

    # only compute on the relevant scales
    rr = dr[m]
    t = -rr/(alpha*np.sqrt(2))
    q = 0.5*(1 + erf(t)) - np.sqrt(0.5/np.pi)*(alpha/(rr+a+1e-10)) * np.exp(-t*t)

    # fill in the grid, inside the interpolation and outside where values are constant
    ans = 0*dr
    ans[m] = q
    ans[dr >  cut] = 0
    ans[dr < -cut] = 1
    return ans

def sphere_analytical_gaussian_fast(dr, a, alpha=0.2765, cut=1.20):
    """
    See sphere_analytical_gaussian_trim, but implemented in C with
    fast erf and exp approximations found at
        Abramowitz and Stegun: Handbook of Mathematical Functions
        A Fast, Compact Approximation of the Exponential Function

    The default cut 1.25 was chosen based on the accuracy of fast_erf
    """

    functions = """
    double fast_erf(double x){
        double sgn = 1.0;

        if (x < 0){
            sgn = -1.0;
            x = -x;
        }

        double p = 0.47047;
        double a1 =  0.3480242;
        double a2 = -0.0958798;
        double a3 =  0.7478556;
        double t1 = 1.0/(1 + p*x);
        double t2 = t1*t1;
        double t3 = t1*t2;
        return sgn*(1 - (a1*t1 + a2*t2 + a3*t3)*exp(-x*x));
    }

    static union
    {
        double d;
        struct
        {
            #ifdef LITTLE_ENDIAN
                int j, i;
            #else
                int i, j;
            #endif
        } n;
    } _eco;

    #define EXP_A (1048576 /M_LN2)
    #define EXP_C 60801
    #define fast_exp(y) (_eco.n.i = EXP_A*(y) + (1072693248 - EXP_C), _eco.d)
    """

    code = """
    double coeff1 = 1.0/(alpha*sqrt(2.0));
    double coeff2 = sqrt(0.5/pi)*alpha;

    for (int i=0; i<N; i++){
        double dri = dr[i];
        if (dri < cut && dri > -cut){
            double t = -dri*coeff1;
            ans[i] = 0.5*(1+fast_erf(t)) - coeff2/(dri+a+1e-10) * fast_exp(-t*t);
        } else {
            ans[i] = 0.0*(dri > cut) + 1.0*(dri < -cut);
        }
    }
    """

    shape = r.shape
    r = r.flatten()
    N = r.shape[0]
    ans = r*0
    pi = np.pi

    inline(code, arg_names=['dr', 'a', 'alpha', 'cut', 'ans', 'pi', 'N'],
            support_code=functions, verbose=0)
    return ans.reshape(shape)

def sphere_constrained_cubic(dr, a, alpha):
    """
    Sphere generated by a cubic interpolant constrained to be (1,0) on
    (r0-sqrt(3)/2, r0+sqrt(3)/2), the size of the cube in the (111) direction.
    """
    sqrt3 = np.sqrt(3)

    b_coeff = a*0.5/sqrt3*(1 - 0.6*sqrt3*alpha)/(0.15 + a*a)
    rscl = np.clip(dr, -0.5*sqrt3, 0.5*sqrt3)

    a, d = rscl + 0.5*sqrt3, rscl - 0.5*sqrt3
    return alpha*d*a*rscl + b_coeff*d*a - d/sqrt3

try:
    sphere_analytical_gaussian_fast(np.linspace(0,10,10), 5.0)
except Exception as e:
    sphere_analytical_gaussian_fast = sphere_analytical_gaussian_trim

def exact_volume_sphere(rvec, pos, radius, zscale=1.0, volume_error=1e-5,
        function=sphere_analytical_gaussian, max_radius_change=1e-2, **kwargs):
    """
    Perform an iterative method to calculate the effective sphere that perfectly
    (up to the volume_error) conserves volume.  Return the resulting image
    """
    vol_goal = 4./3*np.pi*radius**3 / zscale
    rprime = radius

    dr = inner(rvec, pos, rprime, zscale=zscale)
    t = function(dr, rprime, **kwargs)
    for i in xrange(MAX_VOLUME_ITERATIONS):
        vol_curr = np.abs(t.sum())
        if np.abs(vol_goal - vol_curr)/vol_goal < volume_error:
            break

        rprime = rprime + 1.0*(vol_goal - vol_curr) / (4*np.pi*rprime**2)

        if np.abs(rprime - radius)/radius > max_radius_change:
            break

        dr = inner(rvec, pos, rprime, zscale=zscale)
        t = function(dr, rprime, **kwargs)

    return t

#=============================================================================
# Actual sphere collection (and slab)
#=============================================================================
class SphereCollectionRealSpace(object):
    def __init__(self, pos, rad, shape, support_size=4, typ=None, pad=None,
                 method='exact-gaussian-fast', alpha=None, method_function=None,
                 exact_volume=True, volume_error=1e-5, max_radius_change=1e-2):
        """
        method can be one of:
            [
                'lerp', 'logistic', 'triangle', 'constrained-cubic',
                'exact-gaussian', 'exact-gaussian-trim', 'exact-gaussian-fast'
            ]

        Parameters:
        -----------
        method_function : function
            [not implemented] placeholder for providing your own sphere
            generation function

        exact_volume : boolean
            whether to iterate effective particle size until exact volume
            (within volume_error) is achieved

        volume_error : float
            relative volume error tolerance in iteration steps

        max_radius_change : float
            maximum relative radius change allowed during iteration (due to
            edge particles and other confounding factors)
        """
        self.support_size = support_size
        self.pos = pos.astype('float')
        self.rad = rad.astype('float')
        self.N = rad.shape[0]
        self.exact_volume = exact_volume
        self.volume_error = volume_error
        self.max_radius_change = max_radius_change

        # set the aliasing method and coefficient
        # FIXME -- check if function for method and set to that instead
        # method='user-defined' and pass method_function
        self._setup_sphere_functions(method=method, alpha=alpha)

        if typ is None:
            self.typ = np.ones(self.N)
            if pad is not None and pad <= self.N:
                self.typ[-pad:] = 0
        else:
            self.typ = typ.astype('float')

        self.shape = shape
        self._setup()

    def set_pos_rad(self, pos, rad):
        self.pos = pos.astype('float')
        self.rad = rad.astype('float')
        self.typ = 1.*np.ones_like(rad)
        self.N = rad.shape[0]

    def _setup_sphere_functions(self, method, alpha=None):
        self.methods = [
            'lerp', 'logistic', 'triangle', 'constrained-cubic',
            'exact-gaussian', 'exact-gaussian-trim', 'exact-gaussian-fast'
        ]

        self.sphere_functions = {
            'lerp': sphere_lerp,
            'logistic': sphere_logistic,
            'triangle': sphere_triangle_cdf,
            'exact-gaussian': sphere_analytical_gaussian,
            'exact-gaussian-trim': sphere_analytical_gaussian_trim,
            'exact-gaussian-fast': sphere_analytical_gaussian_fast,
            'constrained-cubic': sphere_constrained_cubic
        }

        self.alpha_defaults = {
            'lerp': 0.4539,
            'logistic': 6.5,
            'triangle': 0.6618,
            'exact-gaussian': 0.27595,
            'exact-gaussian-trim': 0.27595,
            'exact-gaussian-fast': 0.27595,
            'constrained-cubic': 0.84990,
        }

        self.method = method
        self.alpha = alpha if alpha is not None else self.alpha_defaults[self.method]

    def _setup(self):
        self.rvecs = Tile(self.shape).coords(form='vector')
        self.particles = np.zeros(self.shape)
        self._diff_field = np.zeros(self.shape)

    def _particle(self, pos, rad, zscale, sign=1, dodiff=False):
        p = np.round(pos)
        r = np.round(np.array([1.0/zscale,1,1])*np.ceil(rad)+self.support_size)

        tile = Tile(p-r, p+r, 0, self.shape)
        rvec = self.rvecs[tile.slicer + (np.s_[:],)]

        # keep backwards compatibility for save files with older logistic coefficient
        # FIXME -- this is a nasty hack which should be fazed out when older save
        # files are deleted
        if not hasattr(self, 'exact_volume'):
            self.exact_volume = False
            self.volume_error = 1e-6
        if not hasattr(self, 'method'):
            self._setup_sphere_functions('logistic', 5.0)
        if not hasattr(self, 'alpha'):
            self._setup_sphere_functions(self.method)
        if not hasattr(self, 'max_radius_change'):
            self.max_radius_change = 1e-2

        # if required, do an iteration to find the best radius to produce
        # the goal volume as given by the particular goal radius
        if self.exact_volume:
            t = sign*exact_volume_sphere(
                    rvec, pos, rad, zscale=zscale, volume_error=self.volume_error,
                    function=self.sphere_functions[self.method], alpha=self.alpha,
                    max_radius_change=self.max_radius_change
                )
        else:
            # calculate the anti-aliasing according to the interpolation type
            dr = inner(rvec, pos, rad, zscale=zscale)
            t = sign*self.sphere_functions[self.method](dr, rad, self.alpha)

        self.particles[tile.slicer] += t

        if dodiff:
            self._diff_field[tile.slicer] += t

    def _update_particle(self, n, p, r, t, zscale, dodiff=True):
        if self.typ[n] == 1:
            self._particle(self.pos[n], self.rad[n], zscale, -1, dodiff=dodiff)

        self.pos[n] = p
        self.rad[n] = r
        self.typ[n] = t

        if self.typ[n] == 1:
            self._particle(self.pos[n], self.rad[n], zscale, +1, dodiff=dodiff)

    def initialize(self, zscale):
        if len(self.pos.shape) != 2:
            raise AttributeError("Position array needs to be (-1,3) shaped, (z,y,x) order")

        self.particles = np.zeros(self.shape)
        for p0, r0, t0 in zip(self.pos, self.rad, self.typ):
            if t0 == 1:
                self._particle(p0, r0, zscale)

    def set_tile(self, tile):
        self.tile = tile

    def update(self, ns, pos, rad, typ, zscale, difference=True):
        for n, p, r, t in zip(ns, pos, rad, typ):
            self._update_particle(n, p, r, t, zscale, dodiff=difference)

    def get_field(self):
        return self.particles[self.tile.slicer]

    def get_diff_field(self):
        c = self._diff_field[self.tile.slicer].copy()
        self._diff_field[self.tile.slicer] *= 0
        return c

    def get_support_size(self, p0, r0, t0, p1, r1, t1, zscale):
        rsc = self.support_size

        zsc = np.array([1.0/zscale, 1, 1])
        r0, r1 = zsc*r0, zsc*r1

        off0 = r0 + rsc
        off1 = r1 + rsc

        if t0[0] == 1 and t1[0] == 1:
            pl = amin(p0-off0-1, p1-off1-1)
            pr = amax(p0+off0+1, p1+off1+1)
        if t0[0] != 1 and t1[0] == 1:
            pl = (p1-off1-1)
            pr = (p1+off1+1)
        if t0[0] == 1 and t1[0] != 1:
            pl = (p0-off0-1)
            pr = (p0+off0+1)
        if t0[0] != 1 and t1[0] != 1:
            c = np.array(self.shape)
            pl = c/2 - c/8
            pr = c/2 + c/8

        if len(pl.shape) > 1:
            pl = pl[0]
            pr = pr[0]
        return pl, pr

    def get_params(self):
        return np.hstack([self.pos.ravel(), self.rad])

    def get_params_pos(self):
        return self.pos.ravel()

    def get_params_rad(self):
        return self.rad

    def get_params_typ(self):
        return self.typ

    def __getstate__(self):
        odict = self.__dict__.copy()
        cdd(odict, ['rvecs', 'particles', '_diff_field'])
        return odict

    def __setstate__(self, idict):
        self.__dict__.update(idict)
        self._setup()


class Slab(object):
    def __init__(self, zpos, shape, normal=(1,0,0)):
        self.zpos = float(zpos)
        self.normal = np.array(normal).astype('float')
        self.normal /= np.sqrt(self.normal.dot(self.normal))

        self.shape = shape
        self._setup()

    def _setup(self):
        self.rvecs = Tile(self.shape).coords(form='vector')
        self.image = np.zeros(self.shape)

    def _slab(self, zpos, norm, sign=1):
        # for the position at zpos, and the center in the x-y plane
        pos = np.array([zpos, self.shape[1]/2, self.shape[2]/2])

        p = (self.rvecs - pos).dot(norm)
        self.image = 1.0/(1.0 + np.exp(7*p))

    def initialize(self):
        self.image = np.zeros(self.shape)
        self._slab(self.zpos, self.normal)

    def set_tile(self, tile):
        self.tile = tile

    def update(self, params):
        zpos, norm = params[0], params[1:]
        norm = norm / np.sqrt(norm.dot(norm))

        self.zpos = zpos
        self.normal = norm

        self._slab(self.zpos, self.normal, +1)

    def get_field(self):
        return self.image[self.tile.slicer]

    def get_support_size(self, p=None):
        return np.zeros(3), np.array(self.shape)

    def get_params(self):
        return np.hstack([self.zpos, self.normal.ravel()])

    def __getstate__(self):
        odict = self.__dict__.copy()
        cdd(odict, ['rvecs', 'image'])
        return odict

    def __setstate__(self, idict):
        self.__dict__.update(idict)
        self._setup()

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{} <{}, {}>".format(str(self.__class__.__name__), self.zpos, list(self.normal))
